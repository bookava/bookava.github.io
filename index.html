<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bookava Player</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/images/favicon.svg" />
    <link rel="shortcut icon" href="/images/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Bookava" />
    <link rel="manifest" href="/images/site.webmanifest" />
    <style>
        :root {
            /* New Teal-based Dark Theme */
            --primary-color: #539E8F;
            --primary-hover-color: #6B9694;
            --primary-glow-color: rgba(83, 158, 143, 0.5);
            --background-color: #1f2937;
            --surface-color: #374151;
            --text-color: #f3f4f6;
            --text-muted-color: #9ca3af;
            --border-color: rgba(255, 255, 255, 0.2);
            --error-color: #EF4444;

            --border-radius-lg: 24px;
            --border-radius-md: 14px;
            --transition-speed: 0.4s;
        }

        body.light-theme {
            --primary-color: #8B5CF6;
            --primary-hover-color: #7C3AED;
            --primary-glow-color: rgba(139, 92, 246, 0.5);
            --background-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #1a202c;
            --text-muted-color: #718096;
            --border-color: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--background-color);
            transition: background-color var(--transition-speed);
            color: var(--text-color);
            -webkit-font-smoothing: antialiased;
        }

        .container {
            width: 100%;
            max-width: 420px;
            background: var(--surface-color);
            border-radius: var(--border-radius-lg);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transition: background-color var(--transition-speed);
            overflow: hidden;
            position: relative;
        }

        /* --- NOTIFICATION --- */
        #notification {
            position: absolute;
            top: 1.5rem;
            left: 1.5rem;
            right: 1.5rem;
            background-color: var(--primary-color);
            color: white;
            padding: 1rem;
            border-radius: var(--border-radius-md);
            text-align: center;
            font-weight: 600;
            transform: translateY(-150%);
            transition: transform 0.4s ease-in-out;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        #notification.show {
            transform: translateY(0);
        }

        #notification.error {
            background-color: var(--error-color);
        }

        #notification svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        /* --- VIEW TRANSITIONS --- */
        .view {
            transition: opacity var(--transition-speed) ease-in-out, visibility var(--transition-speed) ease-in-out;
        }

        .view:not(.visible) {
            opacity: 0;
            visibility: hidden;
            display: none;
        }

        .view.visible {
            opacity: 1;
            visibility: visible;
            display: block;
        }


        /* UPLOAD SECTION */
        .upload-section {
            padding: 2rem 2.5rem 2.5rem;
        }

        .upload-header {
            text-align: center;
        }

        .upload-header h1 {
            margin: 0 0 0.25rem;
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: -1.5px;
        }

        .upload-header p {
            margin-bottom: 2.5rem;
            color: var(--text-muted-color);
            font-size: 1.1rem;
        }

        .upload-drop-zone {
            cursor: pointer;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 2.5rem;
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius-md);
            transition: all 0.3s ease-in-out;
        }

        .upload-drop-zone.dragover {
            border-color: var(--primary-color);
            background-color: rgba(83, 158, 143, 0.1);
            transform: scale(1.02);
        }
        
        body.light-theme .upload-drop-zone.dragover {
             background-color: rgba(139, 92, 246, 0.1);
        }

        .upload-drop-zone svg {
            width: 48px;
            height: 48px;
            margin-bottom: 1rem;
            fill: var(--primary-color);
            transition: transform 0.3s ease-in-out;
        }

        .upload-drop-zone:hover svg {
            transform: scale(1.1);
        }

        .upload-drop-zone span {
            font-weight: 600;
            font-size: 1.1rem;
            display: block;
        }

        .upload-drop-zone .subtext {
            font-size: 0.9rem;
            color: var(--text-muted-color);
            margin-top: 0.25rem;
        }

        #file-input {
            display: none;
        }

        .loader {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
            display: none;
        }

        /* --- BOOKSHELF (HISTORY) SECTION --- */
        .history-section {
            margin-top: 3rem;
            perspective: 1000px;
            /* Add perspective for 3D effects */
        }

        .history-section h2 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-muted-color);
            text-align: center;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 2rem 1.5rem;
            justify-items: center;
        }

        .history-item {
            width: 110px;
            cursor: pointer;
            text-align: center;
            transition: transform 0.3s ease;
            position: relative;
        }

        .history-item:hover {
            transform: translateY(-10px);
        }

        .history-item:hover .history-item-artwork {
            transform: rotateY(8deg) rotateX(2deg) scale(1.08);
            box-shadow: 0 18px 35px rgba(0, 0, 0, 0.3), 0 0 20px -5px var(--primary-glow-color);
        }

        .history-item-remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 28px;
            height: 28px;
            background: var(--error-color);
            border: 2px solid var(--surface-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s ease-in-out;
        }

        .history-item:hover .history-item-remove-btn {
            opacity: 1;
            transform: scale(1);
        }

        .history-item-remove-btn:hover {
            transform: scale(1.1) !important;
            background: #f87171;
        }

        .history-item-remove-btn svg {
            width: 18px;
            height: 18px;
            stroke: white;
            stroke-width: 2.5;
        }


        .history-item-artwork {
            width: 100%;
            height: 150px;
            border-radius: var(--border-radius-md);
            background: linear-gradient(45deg, #2f3046, #2a2b3f);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 0.85rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            transform-style: preserve-3d;
        }

        .history-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .history-item-artwork .artwork-icon {
            width: 40%;
            height: 40%;
            fill: var(--text-muted-color);
            opacity: 0.3;
        }

        .history-item .title {
            color: var(--text-color);
            font-size: 0.85rem;
            font-weight: 500;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-box-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.3s;
        }

        .history-item:hover .title {
            color: var(--primary-color);
        }


        /* PLAYER SECTION */
        .player-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem 0.5rem;
        }

        .player-header button {
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s, transform 0.2s;
            padding: 0.5rem;
        }

        .player-header button:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .player-header button svg {
            width: 28px;
            height: 28px;
            fill: var(--text-color);
        }

        .main-player {
            padding: 0 2.5rem 1.5rem;
            text-align: center;
        }

        #artwork-placeholder {
            width: 100%;
            max-width: 260px;
            aspect-ratio: 1 / 1;
            margin: 1rem auto 2rem;
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border-radius: var(--border-radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
        }

        #artwork-placeholder img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: var(--border-radius-md);
        }

        #artwork-placeholder svg {
            width: 60px;
            height: 60px;
            opacity: 0.3;
            fill: var(--text-color);
        }

        #current-track {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #current-album {
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-muted-color);
            margin-bottom: 1.5rem;
        }

        .progress-container {
            position: relative;
            margin: 1rem 0;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-muted-color);
            margin: 0.75rem 0 1.5rem;
        }

        #progress-tooltip {
            position: absolute;
            background-color: var(--background-color);
            color: var(--text-color);
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            bottom: 35px;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 10;
        }


        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
            transition: height 0.2s;
        }
        
        /* FIX: Light theme visibility for sliders */
        body.light-theme input[type="range"] {
            background: #e2e8f0;
        }

        input[type="range"]:hover {
            height: 8px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            border: 2px solid var(--surface-color);
            box-shadow: 0 0 5px var(--primary-glow-color);
            transition: transform 0.2s;
        }

        input[type="range"]:hover::-webkit-slider-thumb {
            transform: scale(1.1);
        }

        .playback-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
        }

        .playback-controls button {
            background: transparent;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: inline-grid;
            place-items: center;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-muted-color);
        }

        .playback-controls button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--text-color);
        }
        
        body.light-theme .playback-controls button:hover:not(:disabled) {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .playback-controls button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .playback-controls button svg {
            fill: currentColor;
            transition: fill 0.2s;
        }

        .seek-btn {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 1rem;
        }

        #play-pause-btn {
            width: 70px;
            height: 70px;
            background-color: var(--primary-color);
            color: white;
        }

        #play-pause-btn:hover {
            background-color: var(--primary-hover-color);
            transform: scale(1.05);
        }

        #play-pause-btn svg {
            width: 32px;
            height: 32px;
            transform: translateX(1px);
            /* Optical alignment for play icon */
        }

        #play-pause-btn .pause-icon svg {
            transform: translateX(0px);
        }

        #prev-btn svg,
        #next-btn svg {
            width: 32px;
            height: 32px;
        }

        .speed-control-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            /* Adjusted gap */
            margin-top: 1.5rem;
        }

        .speed-btn {
            font-family: 'Inter', sans-serif;
            font-size: 1.4rem;
            line-height: 1;
            font-weight: bold;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            background: transparent;
            color: var(--text-muted-color);
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        #auto-speed-btn.active {
            border-color: var(--primary-color);
            color: var(--primary-color);
            background: rgba(83, 158, 143, 0.1);
        }
        
        body.light-theme #auto-speed-btn.active {
            background: rgba(139, 92, 246, 0.1);
        }


        .speed-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .speed-btn:not(#auto-speed-btn):hover:not(:disabled) {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        #auto-speed-btn:hover:not(:disabled) {
            border-color: var(--primary-color);
            color: var(--primary-color);
            background: rgba(83, 158, 143, 0.15);
        }
        
        body.light-theme #auto-speed-btn:hover:not(:disabled) {
            background: rgba(139, 92, 246, 0.15);
        }

        #speed-label {
            text-align: center;
            font-weight: 600;
            font-size: 1.2rem;
            min-width: 70px;
            /* Wider to accommodate 'auto' */
        }

        #speed-label .auto-indicator {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--primary-color);
            display: block;
        }


        .total-time-info {
            text-align: center;
            font-size: 0.85rem;
            color: var(--text-muted-color);
            margin-top: 1rem;
            height: 1em;
        }

        .bottom-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1.5rem 1rem;
        }

        .volume-control-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #volume-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s, transform 0.2s;
        }

        #volume-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        #volume-btn svg {
            width: 28px;
            height: 28px;
            fill: var(--text-color);
        }

        #volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 5px;
            cursor: pointer;
            /* Background is handled by the generic input[type=range] rule */
            border-radius: 3px;
        }

        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--text-color);
            border-radius: 50%;
        }


        .playlist-section {
            max-height: 250px;
            overflow-y: auto;
            border-top: 1px solid var(--border-color);
        }

        #playlist {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #playlist li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid var(--border-color);
        }

        #playlist li:last-child {
            border-bottom: none;
        }

        #playlist li:hover {
            background-color: rgba(255, 255, 255, 0.04);
        }
        
        body.light-theme #playlist li:hover {
            background-color: rgba(0, 0, 0, 0.03);
        }

        #playlist li.active {
            background-color: rgba(83, 158, 143, 0.15);
            color: var(--primary-color);
        }
        
        body.light-theme #playlist li.active {
            background-color: rgba(139, 92, 246, 0.15);
        }

        .playlist-track-info {
            display: flex;
            align-items: center;
            overflow: hidden;
            padding-right: 1rem;
        }

        .now-playing-icon {
            display: flex;
            gap: 2px;
            width: 16px;
            height: 16px;
            margin-right: 12px;
            align-items: flex-end;
            display: none;
        }

        #playlist li.active .now-playing-icon {
            display: flex;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: scaleY(0.4);
            }

            50% {
                transform: scaleY(1);
            }
        }

        .now-playing-icon .bar {
            width: 3px;
            height: 100%;
            background: var(--primary-color);
            animation: bounce 1.2s ease-in-out infinite;
        }

        .now-playing-icon .bar:nth-child(2) {
            animation-delay: -1.0s;
        }

        .now-playing-icon .bar:nth-child(3) {
            animation-delay: -0.8s;
        }

        .playlist-track-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: 500;
        }

        #playlist li.active .playlist-track-title {
            font-weight: 700;
            color: var(--primary-color);
        }

        .playlist-track-duration {
            font-size: 0.85rem;
            color: var(--text-muted-color);
            font-weight: 500;
            white-space: nowrap;
        }

        /* MODAL */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-in-out;
            z-index: 1000;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--surface-color);
            border-radius: var(--border-radius-lg);
            padding: 2rem;
            text-align: center;
            max-width: 340px;
            width: 90%;
            transform: scale(0.95) translateY(20px);
            transition: all 0.3s ease-in-out;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
        }

        .modal-overlay.visible .modal-content {
            transform: scale(1) translateY(0);
        }

        .modal-content h3 {
            margin-top: 0;
            font-size: 1.5rem;
        }

        .modal-content p {
            color: var(--text-muted-color);
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
        }

        .modal-buttons button {
            flex: 1;
            padding: 0.8rem;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            border-radius: var(--border-radius-md);
            transition: all 0.2s;
            border: none;
        }

        .modal-buttons .modal-secondary-btn {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-color);
        }

        .modal-buttons .modal-secondary-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        body.light-theme .modal-buttons .modal-secondary-btn {
            background: rgba(0, 0, 0, 0.08);
        }
        
        body.light-theme .modal-buttons .modal-secondary-btn:hover {
            background: rgba(0, 0, 0, 0.15);
        }

        .modal-buttons .modal-primary-btn {
            background: var(--primary-color);
            color: white;
        }

        .modal-buttons .modal-primary-btn:hover {
            background: var(--primary-hover-color);
        }

        #theme-toggle-btn {
            position: fixed;
            /* Changed from absolute to fixed */
            top: 1.5rem;
            right: 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s, transform 0.2s;
            padding: 0.5rem;
            z-index: 1001;
            /* Z-index is higher than modal overlay */
        }

        #theme-toggle-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        #theme-toggle-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--text-color);
            stroke: var(--text-color);
        }


        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        @media (min-width: 1024px) {
            .container {
                max-width: 900px; /* Wider container for desktop */
            }
        
            /* Desktop Player Layout */
            .player-section.view.visible {
                display: grid;
                grid-template-columns: 1fr 320px; /* Two-column layout */
                grid-template-rows: auto 1fr;
                grid-template-areas:
                    "header header"
                    "main-player playlist";
                gap: 0 2rem;
                padding-bottom: 1rem;
            }
        
            .player-header {
                grid-area: header;
                padding: 1rem 2.5rem 0.5rem;
            }
        
            .main-player {
                grid-area: main-player;
                padding: 0 2.5rem 1.5rem;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
        
            #artwork-placeholder {
                max-width: 100%; /* Allow artwork to be larger */
            }
        
            .playlist-section {
                grid-area: playlist;
                max-height: none; /* Remove max-height on desktop */
                border-top: none;
                border-left: 1px solid var(--border-color);
                overflow-y: auto;
                display: flex;
                flex-direction: column;
            }
            
            #playlist {
                flex-grow: 1;
            }
        
            .playlist-section::-webkit-scrollbar {
                width: 8px;
            }
        
            .playlist-section::-webkit-scrollbar-track {
                background: transparent;
            }
        
            .playlist-section::-webkit-scrollbar-thumb {
                background: var(--border-color);
                border-radius: 4px;
            }
        
            .playlist-section::-webkit-scrollbar-thumb:hover {
                background: var(--text-muted-color);
            }
            
            .bottom-controls {
                /* These controls are now in the header for desktop */
                display: none;
            }
        
            /* Re-enable volume controls in the header for desktop */
            .player-header .volume-control-container {
                display: flex;
            }
        
        
            /* Desktop Upload and History Layout */
            .upload-section {
                padding: 3rem 4rem 4rem;
            }
        
            .history-grid {
                /* Show more items per row on desktop */
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 2.5rem 2rem;
            }
        
            .history-item {
                width: 130px;
            }
        
            .history-item-artwork {
                height: 170px;
            }
        }
        
        /* Adjustments for medium-sized screens like tablets */
        @media (min-width: 768px) and (max-width: 1023px) {
            .container {
                max-width: 600px;
            }
        
            .history-grid {
                grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            }
        }
    </style>
</head>

<body>
    <button id="theme-toggle-btn" title="Toggle Theme"></button>
    <div class="container">
        <div id="notification"></div>

        <!-- UPLOAD VIEW -->
        <div class="upload-section view visible" id="upload-section">
            <div class="upload-header">
                <h1>Bookava</h1>
                <p>Your personal audiobook player.</p>
            </div>
            <label for="file-input" class="upload-drop-zone" id="upload-drop-zone">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path
                        d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z" />
                </svg>
                <span>Choose Audiobook</span>
                <span class="subtext">Drop .zip, .m4b or audio files here</span>
            </label>
            <input type="file" id="file-input" accept=".zip,.mp3,.wav,.ogg,.m4a,.m4b,.flac" multiple>
            <div class="loader" id="loader"></div>
            <div class="history-section" id="history-section">
                <h2>Bookshelf</h2>
                <div class="history-grid" id="history-grid">
                    <!-- History items will be injected here -->
                </div>
            </div>
        </div>

        <!-- PLAYER VIEW -->
        <div class="player-section view" id="player-section">
            <div class="player-header">
                <button id="back-btn" title="Back to Bookshelf">
                    <svg viewBox="0 0 24 24">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" />
                    </svg>
                </button>
                <div class="volume-control-container">
                    <button id="volume-btn" title="Volume"></button>
                    <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="1" />
                </div>
            </div>
            <div class="main-player">
                <div id="artwork-placeholder"></div>
                <h2 id="current-track">Track Title</h2>
                <h3 id="current-album">Album Title</h3>

                <div class="progress-container">
                    <div id="progress-tooltip">0:00</div>
                    <input type="range" id="progress-bar" value="0" step="0.1">
                    <div class="time-display">
                        <span id="current-time">0:00</span>
                        <span id="total-duration">0:00</span>
                    </div>
                </div>

                <div class="playback-controls">
                    <button id="rewind-btn" class="seek-btn" title="Rewind 15s (←)">-15s</button>
                    <button id="prev-btn" title="Previous"><svg viewBox="0 0 24 24">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
                        </svg></button>
                    <button id="play-pause-btn" title="Play/Pause (Space)"></button>
                    <button id="next-btn" title="Next"><svg viewBox="0 0 24 24">
                            <path d="M6 5v14l11-7zM18 6h-2v12h2z" />
                        </svg></button>
                    <button id="forward-btn" class="seek-btn" title="Forward 15s (→)">+15s</button>
                </div>

                <div class="speed-control-group">
                    <button id="speed-down-btn" class="speed-btn" title="Decrease Speed">-</button>
                    <span id="speed-label">1.0x</span>
                    <button id="speed-up-btn" class="speed-btn" title="Increase Speed">+</button>
                    <button id="auto-speed-btn" class="speed-btn" title="Auto-speed (+0.1x / 10min)">
                        <svg viewBox="0 0 24 24" fill="currentColor"
                            style="width: 22px; height: 22px; pointer-events: none;">
                            <path
                                d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z" />
                        </svg>
                    </button>
                </div>
                <div id="total-time-info" class="total-time-info"></div>

            </div>

            <div class="playlist-section">
                <ul id="playlist"></ul>
            </div>
        </div>
    </div>

    <!-- RESUME MODAL -->
    <div class="modal-overlay" id="resume-modal">
        <div class="modal-content">
            <h3>Welcome Back!</h3>
            <p>Continue your listening session for <strong id="resume-title">this audiobook</strong> from where you left
                off?</p>
            <div class="modal-buttons">
                <button class="modal-secondary-btn" id="resume-no">Start Over</button>
                <button class="modal-primary-btn" id="resume-yes">Yes, Resume</button>
            </div>
        </div>
    </div>

    <!-- HISTORY LOAD MODAL -->
    <div class="modal-overlay" id="history-load-modal">
        <div class="modal-content">
            <h3>Load from Bookshelf</h3>
            <p>To continue listening, please re-select the original audiobook file(s). Your browser's security settings
                require this confirmation.</p>
            <div class="modal-buttons">
                <button class="modal-secondary-btn" id="history-load-cancel">Cancel</button>
                <button class="modal-primary-btn" id="history-load-select">Select File(s)</button>
            </div>
        </div>
    </div>


    <!-- Libraries -->
    <script src="/js/zip-full.min.js"></script>
    <script src="/js/crypto-js.min.js"></script>

    <script type="module">
        // Dynamically import the ES module version of the music-metadata library.
        // This must be done at the top level of a module script.
        const mm = await import('https://esm.sh/music-metadata');
        
        // Since this is a module script that runs after the body is parsed,
        // we can define all our code without a DOMContentLoaded wrapper.
        const dom = {
            fileInput: document.getElementById('file-input'),
            backBtn: document.getElementById('back-btn'),
            uploadDropZone: document.getElementById('upload-drop-zone'),
            uploadSection: document.getElementById('upload-section'),
            playerSection: document.getElementById('player-section'),
            loader: document.getElementById('loader'),
            currentTrackEl: document.getElementById('current-track'),
            currentAlbumEl: document.getElementById('current-album'),
            playPauseBtn: document.getElementById('play-pause-btn'),
            rewindBtn: document.getElementById('rewind-btn'),
            forwardBtn: document.getElementById('forward-btn'),
            prevBtn: document.getElementById('prev-btn'),
            nextBtn: document.getElementById('next-btn'),
            progressBar: document.getElementById('progress-bar'),
            progressTooltip: document.getElementById('progress-tooltip'),
            currentTimeEl: document.getElementById('current-time'),
            totalDurationEl: document.getElementById('total-duration'),
            speedLabel: document.getElementById('speed-label'),
            speedDownBtn: document.getElementById('speed-down-btn'),
            speedUpBtn: document.getElementById('speed-up-btn'),
            autoSpeedBtn: document.getElementById('auto-speed-btn'),
            playlistEl: document.getElementById('playlist'),
            artworkPlaceholder: document.getElementById('artwork-placeholder'),
            resumeModal: document.getElementById('resume-modal'),
            resumeTitle: document.getElementById('resume-title'),
            resumeYesBtn: document.getElementById('resume-yes'),
            resumeNoBtn: document.getElementById('resume-no'),
            historyGrid: document.getElementById('history-grid'),
            historySection: document.getElementById('history-section'),
            historyLoadModal: document.getElementById('history-load-modal'),
            historyLoadCancel: document.getElementById('history-load-cancel'),
            historyLoadSelect: document.getElementById('history-load-select'),
            notification: document.getElementById('notification'),
            volumeBtn: document.getElementById('volume-btn'),
            volumeSlider: document.getElementById('volume-slider'),
            totalTimeInfo: document.getElementById('total-time-info'),
            themeToggleBtn: document.getElementById('theme-toggle-btn'),
        };

        const audio = new Audio();
        let playlistFiles = [];
        let currentTrackIndex = 0;
        let currentBookId = null;
        let pendingBookIdFromHistory = null;
        let saveInterval = null;
        let overallBookTitle = 'Untitled Audiobook';
        let overallBookArtwork = null;
        let totalPlaylistDuration = 0;
        let autoSpeedActive = false;
        let autoSpeedIntervalId = null;
        let isSingleM4B = false;

        const SPEED_MIN = 0.5,
            SPEED_MAX = 16.0,
            SPEED_INCREMENT = 0.1;
        const AUTO_SPEED_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes
        const AUTO_SPEED_INCREMENT = 0.1;

        const HISTORY_KEY = 'bookava_history_v4';
        const MAX_HISTORY_ITEMS = 6;

        const playIcon = `<svg class="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`;
        const pauseIcon = `<svg class="pause-icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;
        const artworkIcon = `<svg class="artwork-icon" viewBox="0 0 24 24"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/></svg>`;
        const volumeIcons = {
            high: `<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>`,
            low: `<svg viewBox="0 0 24 24"><path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"/></svg>`,
            muted: `<svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>`,
        };
        const notificationIcons = {
            info: `<svg viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>`,
            error: `<svg viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg>`,
        }
        const themeIcons = {
            dark: `<svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`,
            light: `<svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg>`,
        }

        const setupEventListeners = () => {
            dom.fileInput.addEventListener('change', (e) => handleFileUpload(e.target.files));
            dom.backBtn.addEventListener('click', goBackToUpload);
            dom.playPauseBtn.addEventListener('click', togglePlayPause);
            dom.rewindBtn.addEventListener('click', () => seekRelative(-15));
            dom.forwardBtn.addEventListener('click', () => seekRelative(15));
            dom.prevBtn.addEventListener('click', playPrevious);
            dom.nextBtn.addEventListener('click', playNext);
            dom.speedDownBtn.addEventListener('click', () => changeSpeed(-SPEED_INCREMENT));
            dom.speedUpBtn.addEventListener('click', () => changeSpeed(SPEED_INCREMENT));
            dom.autoSpeedBtn.addEventListener('click', toggleAutoSpeed);
            dom.progressBar.addEventListener('input', setSeek);
            dom.progressBar.addEventListener('mousemove', updateProgressTooltip);
            dom.progressBar.addEventListener('mouseenter', () => dom.progressTooltip.style.opacity = '1');
            dom.progressBar.addEventListener('mouseleave', () => dom.progressTooltip.style.opacity = '0');

            audio.addEventListener('timeupdate', updateProgress);
            audio.addEventListener('loadedmetadata', handleTrackMetadata);
            audio.addEventListener('ended', handleAudioEnded);
            audio.addEventListener('volumechange', updateVolumeUI);
            dom.volumeSlider.addEventListener('input', () => {
                audio.muted = false;
                audio.volume = dom.volumeSlider.value
            });
            dom.volumeBtn.addEventListener('click', toggleMute);

            dom.historyLoadCancel.addEventListener('click', () => {
                dom.historyLoadModal.classList.remove('visible');
                pendingBookIdFromHistory = null;
            });
            dom.historyLoadSelect.addEventListener('click', () => {
                dom.historyLoadModal.classList.remove('visible');
                dom.fileInput.click();
            });

            audio.onplay = () => {
                dom.playPauseBtn.innerHTML = pauseIcon;
                if (autoSpeedActive) startAutoSpeed();
            };
            audio.onpause = () => {
                dom.playPauseBtn.innerHTML = playIcon;
                saveState();
                stopAutoSpeed();
            };
            window.addEventListener('beforeunload', saveState);

            const dropZone = dom.uploadDropZone;
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                if (e.dataTransfer.files.length) handleFileUpload(e.dataTransfer.files);
            });

            dom.themeToggleBtn.addEventListener('click', toggleTheme);
            document.addEventListener('keydown', handleKeyboardShortcuts);
        };

        const showNotification = (message, type = 'info') => {
            dom.notification.innerHTML = `${notificationIcons[type]}<span>${message}</span>`;
            dom.notification.className = type;
            dom.notification.classList.add('show');
            setTimeout(() => dom.notification.classList.remove('show'), 4000);
        };

        async function generateBookId(files, albumTitle) {
            if (albumTitle && albumTitle !== 'Untitled Audiobook' && albumTitle !== 'Collection') {
                return `book-id-${albumTitle.replace(/\s+/g, '-').toLowerCase()}`;
            }
            const fileDetails = Array.from(files).map(f => `${f.name}-${f.size}`).sort().join('|');
            const hash = CryptoJS.SHA1(fileDetails).toString();
            return `book-id-${hash.substring(0, 12)}`;
        }

        async function handleFileUpload(files) {
            if (files.length === 0) {
                pendingBookIdFromHistory = null;
                return;
            }

            const firstFile = files[0];
            const isZipFile = files.length === 1 && firstFile.name.endsWith('.zip');
            const isM4BFile = files.length === 1 && firstFile.name.endsWith('.m4b');
            const areAudioFiles = Array.from(files).every(f => f.type.startsWith('audio/'));

            if (!isZipFile && !areAudioFiles && !isM4BFile) {
                showNotification('Please upload audio files, a single .zip or a .m4b file.', 'error');
                pendingBookIdFromHistory = null;
                return;
            }

            dom.loader.style.display = 'block';
            dom.uploadDropZone.style.display = 'none';
            dom.historySection.style.display = 'none';

            try {
                let extractedFiles = [];
                if (isZipFile) {
                    overallBookTitle = firstFile.name.replace(/\.zip$/i, "");
                    extractedFiles = await unzipFile(firstFile);
                } else {
                    extractedFiles = Array.from(files).map(file => ({
                        name: file.name,
                        url: URL.createObjectURL(file),
                        blob: file
                    }));
                }
                
                if (extractedFiles.length === 0) throw new Error('No supported audio files found.');
                
                const firstProcessedFile = await processFile(extractedFiles[0]);
                overallBookTitle = firstProcessedFile.tags?.album || firstProcessedFile.title;
                overallBookArtwork = firstProcessedFile.artwork || null;
                
                // M4B Chapter Handling
                if (isM4BFile && firstProcessedFile.chapters?.length > 0) {
                    isSingleM4B = true;
                    playlistFiles = firstProcessedFile.chapters.map(chap => ({
                        title: chap.title,
                        startTime: chap.startTime,
                        url: firstProcessedFile.url,
                        artwork: overallBookArtwork,
                    }));
                } else {
                    isSingleM4B = false;
                    playlistFiles = await Promise.all(extractedFiles.map(processFile));
                    playlistFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                    
                    const firstFileWithTags = playlistFiles.find(f => f.tags && f.tags.album);
                    if (firstFileWithTags) overallBookTitle = firstFileWithTags.tags.album;
                    else if (playlistFiles.length > 1 && !isZipFile) overallBookTitle = "Collection";
                    else overallBookTitle = playlistFiles[0].title;

                    const firstFileWithArtwork = playlistFiles.find(f => f.artwork);
                    overallBookArtwork = firstFileWithArtwork ? firstFileWithArtwork.artwork : null;
                }


                currentBookId = await generateBookId(files, overallBookTitle);
                const savedState = getSavedState(currentBookId);

                if (pendingBookIdFromHistory && pendingBookIdFromHistory === currentBookId) {
                    pendingBookIdFromHistory = null;
                    startPlayer(savedState);
                } else if (savedState) {
                    showResumePrompt(savedState);
                } else {
                    startPlayer({ autoplay: true });
                }
            } catch (error) {
                console.error("File handling error:", error);
                showNotification(`Error: ${error.message}`, 'error');
                resetToUploadView();
            }
        }

        const showResumePrompt = (savedState) => {
            dom.resumeTitle.textContent = overallBookTitle;
            dom.resumeModal.classList.add('visible');
            dom.resumeYesBtn.onclick = () => { dom.resumeModal.classList.remove('visible'); startPlayer(savedState); };
            dom.resumeNoBtn.onclick = () => { dom.resumeModal.classList.remove('visible'); startPlayer({ autoplay: true }); localStorage.removeItem(currentBookId); };
        };

        async function startPlayer(initialState = {}) {
            dom.uploadSection.classList.remove('visible');
            dom.playerSection.classList.add('visible');
            dom.loader.style.display = 'none';
            dom.currentAlbumEl.textContent = overallBookTitle;

            if (isSingleM4B) {
                audio.src = playlistFiles[0].url; // Load the single M4B file
            }

            buildPlaylist();

            if (isSingleM4B) {
                // For M4B, duration is of the whole file.
                audio.addEventListener('loadedmetadata', () => {
                   totalPlaylistDuration = audio.duration;
                   updateTotalTimeInfo();
                }, {once: true});
            } else {
                await calculateTotalDuration();
            }

            audio.playbackRate = initialState.speed || 1.0;
            audio.volume = initialState.volume !== undefined ? initialState.volume : 1.0;
            audio.muted = initialState.muted || false;
            autoSpeedActive = initialState.autoSpeedActive || false;

            const shouldAutoplay = initialState.wasPlaying || initialState.autoplay || false;
            const initialTime = initialState.time || (isSingleM4B ? playlistFiles[0].startTime : 0);
            
            loadTrack(initialState.trackIndex || 0, initialTime, shouldAutoplay);
            
            updateAndSaveHistory({
                id: currentBookId,
                title: overallBookTitle,
                artwork: overallBookArtwork
            });

            if (saveInterval) clearInterval(saveInterval);
            saveInterval = setInterval(saveState, 5000);
        }

        function goBackToUpload() {
            saveState();
            resetPlayerState();
            resetToUploadView();
            renderHistory();
        }

        function resetPlayerState() {
            clearInterval(saveInterval);
            saveInterval = null;
            stopAutoSpeed();
            audio.pause();
            audio.src = '';
            playlistFiles.forEach(file => { if (file.url && !isSingleM4B) URL.revokeObjectURL(file.url); });
            playlistFiles = [];
            currentBookId = null;
            pendingBookIdFromHistory = null;
            overallBookArtwork = null;
            overallBookTitle = 'Untitled Audiobook';
            totalPlaylistDuration = 0;
            isSingleM4B = false;
            dom.playlistEl.innerHTML = '';
            dom.totalTimeInfo.textContent = '';
            currentTrackIndex = 0;
            dom.fileInput.value = '';
        }

        function resetToUploadView() {
            dom.playerSection.classList.remove('visible');
            dom.uploadSection.classList.add('visible');
            dom.loader.style.display = 'none';
            dom.uploadDropZone.style.display = 'flex';
            dom.historySection.style.display = 'block';
            dom.playPauseBtn.innerHTML = playIcon;
        }

        function loadTrack(index, startTime = 0, autoplay = false) {
            if (index < 0 || index >= playlistFiles.length) return;

            currentTrackIndex = index;
            const track = playlistFiles[index];

            dom.playPauseBtn.innerHTML = playIcon;
            dom.currentTrackEl.textContent = track.title;
            updateArtwork(track);
            updatePlaylistUI();

            const desiredSpeed = audio.playbackRate;
            
            const canplayHandler = () => {
                audio.playbackRate = desiredSpeed;

                updateSpeedUI();
                updateVolumeUI();
                updateTotalTimeInfo();
                
                if (autoplay) {
                    audio.play().catch(e => {
                        console.warn("Playback was prevented by the browser.", e);
                        dom.playPauseBtn.innerHTML = playIcon;
                    });
                }
            };
            
            if (isSingleM4B) {
                audio.currentTime = startTime || track.startTime;
                canplayHandler();
            } else {
                audio.src = track.url;
                audio.currentTime = startTime;
                audio.addEventListener('canplay', canplayHandler, { once: true });
            }
        }

        function updateArtwork(track) {
            const artworkSrc = track.artwork || overallBookArtwork;
            if (artworkSrc) {
                dom.artworkPlaceholder.innerHTML = `<img src="${artworkSrc}" alt="Artwork for ${track.title}">`;
            } else {
                dom.artworkPlaceholder.innerHTML = artworkIcon;
            }
        }

        function saveState() {
            if (!currentBookId || isNaN(audio.currentTime)) return;
            const state = {
                trackIndex: currentTrackIndex,
                time: audio.currentTime,
                speed: audio.playbackRate,
                volume: audio.volume,
                muted: audio.muted,
                autoSpeedActive: autoSpeedActive,
                wasPlaying: !audio.paused && audio.src,
                bookInfo: {
                    id: currentBookId,
                    title: overallBookTitle,
                    artwork: overallBookArtwork
                }
            };
            try {
                localStorage.setItem(currentBookId, JSON.stringify(state));
            } catch (e) {
                console.error("Could not save state to localStorage.", e);
                showNotification("Could not save progress.", "error");
            }
        }

        const getSavedState = (bookId) => {
            try {
                const state = localStorage.getItem(bookId);
                return state ? JSON.parse(state) : null;
            } catch (e) { return null; }
        }

        function unzipFile(file) {
            return new Promise(async (resolve, reject) => {
                try {
                    const zipReader = new zip.ZipReader(new zip.BlobReader(file));
                    const entries = await zipReader.getEntries();
                    const audioFiles = [];
                    for (const entry of entries) {
                        if (entry.directory || entry.filename.startsWith('__MACOSX/')) continue;
                        if (/\.(mp3|wav|ogg|m4a|flac|m4b)$/i.test(entry.filename)) {
                            const blob = await entry.getData(new zip.BlobWriter());
                            const name = entry.filename.split('/').pop();
                            audioFiles.push({ name, url: URL.createObjectURL(blob), blob });
                        }
                    }
                    await zipReader.close();
                    resolve(audioFiles);
                } catch (e) { reject(new Error("Could not read zip file.")); }
            });
        }

        async function processFile(file) {
            try {
                // Use the dynamically imported module 'mm'
                const metadata = await mm.parseBlob(file.blob);
                file.tags = metadata.common;
                file.chapters = metadata.common.chapters;
                file.title = metadata.common.title || file.name.replace(/\.[^/.]+$/, "");
                if (metadata.common.picture && metadata.common.picture.length > 0) {
                    const picture = metadata.common.picture[0];
                    const blob = new Blob([picture.data], { type: picture.format });
                    file.artwork = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                }
            } catch (error) {
                console.warn(`Could not parse metadata for ${file.name}:`, error);
                file.title = file.name.replace(/\.[^/.]+$/, "");
            }
            return file;
        }

        function handleTrackMetadata() {
            if (isSingleM4B) return; // M4B duration is handled in startPlayer
            const duration = audio.duration;
            dom.progressBar.max = duration;
            dom.totalDurationEl.textContent = formatTime(duration);
        }

        const togglePlayPause = () => {
            if (!audio.src) return;
            if (audio.paused) {
                audio.play().catch(error => console.error("Audio playback failed:", error));
            } else {
                audio.pause();
            }
        };

        const seekRelative = (seconds) => audio.currentTime = Math.max(0, Math.min(audio.duration, audio.currentTime + seconds));
        const playPrevious = () => loadTrack((currentTrackIndex - 1 + playlistFiles.length) % playlistFiles.length, 0, true);
        
        const playNext = () => {
            if(currentTrackIndex >= playlistFiles.length -1) {
                handleAudioEnded();
                return;
            }
            loadTrack((currentTrackIndex + 1) % playlistFiles.length, 0, true);
        };

        const handleAudioEnded = () => {
            // For multi-file books, this is called on 'ended'. For M4B, it's called manually.
            if (isSingleM4B || currentTrackIndex >= playlistFiles.length - 1) {
                showNotification("Audiobook finished!", "info");
                setTimeout(goBackToUpload, 1000);
            } else {
                playNext(); // For multi-file books, proceed to next track
            }
        };
        
        const toggleMute = () => { audio.muted = !audio.muted; };

        function changeSpeed(increment) {
            let newSpeed = parseFloat((audio.playbackRate + increment).toFixed(2));
            newSpeed = Math.max(SPEED_MIN, Math.min(newSpeed, SPEED_MAX));
            audio.playbackRate = newSpeed;
            updateSpeedUI();
            updateTotalTimeInfo();
        }

        function toggleAutoSpeed() {
            autoSpeedActive = !autoSpeedActive;
            updateSpeedUI();
            if (autoSpeedActive && !audio.paused) startAutoSpeed();
            else stopAutoSpeed();
            updateTotalTimeInfo();
        }

        function startAutoSpeed() {
            stopAutoSpeed();
            autoSpeedIntervalId = setInterval(() => {
                changeSpeed(AUTO_SPEED_INCREMENT);
                showNotification(`Speed increased to ${audio.playbackRate.toFixed(1)}x`, 'info');
            }, AUTO_SPEED_INTERVAL_MS);
        }

        function stopAutoSpeed() {
            if (autoSpeedIntervalId) {
                clearInterval(autoSpeedIntervalId);
                autoSpeedIntervalId = null;
            }
        }

        function updateSpeedUI() {
            const currentSpeed = audio.playbackRate;
            dom.speedLabel.innerHTML = `${currentSpeed.toFixed(1)}x ${autoSpeedActive ? '<span class="auto-indicator">auto</span>' : ''}`;
            dom.speedDownBtn.disabled = (currentSpeed.toFixed(2) <= SPEED_MIN);
            dom.speedUpBtn.disabled = (currentSpeed.toFixed(2) >= SPEED_MAX);
            dom.autoSpeedBtn.classList.toggle('active', autoSpeedActive);
        }

        function updateVolumeUI() {
            dom.volumeSlider.value = audio.muted ? 0 : audio.volume;
            if (audio.muted) dom.volumeBtn.innerHTML = volumeIcons.muted;
            else if (audio.volume < 0.5) dom.volumeBtn.innerHTML = volumeIcons.low;
            else dom.volumeBtn.innerHTML = volumeIcons.high;
        }

        function updateProgress() {
            if (isNaN(audio.duration)) return;
            dom.progressBar.max = audio.duration;
            dom.progressBar.value = audio.currentTime;
            dom.currentTimeEl.textContent = formatTime(audio.currentTime);
            dom.totalDurationEl.textContent = formatTime(audio.duration);

            if (isSingleM4B) {
                let activeChapterIndex = -1;
                for (let i = playlistFiles.length - 1; i >= 0; i--) {
                    if (audio.currentTime >= playlistFiles[i].startTime) {
                        activeChapterIndex = i;
                        break;
                    }
                }
                if (activeChapterIndex !== -1 && activeChapterIndex !== currentTrackIndex) {
                    currentTrackIndex = activeChapterIndex;
                    dom.currentTrackEl.textContent = playlistFiles[currentTrackIndex].title;
                    updatePlaylistUI();
                }
            }

            updateTotalTimeInfo();
        }

        function updateProgressTooltip(e) {
            const rect = dom.progressBar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = rect.width;
            const progress = Math.max(0, Math.min(1, x / width));
            const time = progress * audio.duration;

            dom.progressTooltip.textContent = formatTime(time);
            dom.progressTooltip.style.left = `${x}px`;
        }

        const setSeek = () => audio.currentTime = dom.progressBar.value;

        function buildPlaylist() {
            dom.playlistEl.innerHTML = '';
            playlistFiles.forEach((file, index) => {
                const li = document.createElement('li');
                li.dataset.index = index;
                li.innerHTML = `
                    <div class="playlist-track-info">
                        <div class="now-playing-icon"><div class="bar"></div><div class="bar"></div><div class="bar"></div></div>
                        <span class="playlist-track-title">${file.title}</span>
                    </div>
                    <span class="playlist-track-duration">${isSingleM4B ? formatTime(file.startTime) : '--:--'}</span>`;
                li.addEventListener('click', () => { if (currentTrackIndex !== index) loadTrack(index, 0, true); });
                dom.playlistEl.appendChild(li);
            });
        }

        async function getFileDuration(file) {
            return new Promise((resolve) => {
                if (file.duration) {
                    resolve(file.duration);
                    return;
                }
                const tempAudio = new Audio(file.url);
                tempAudio.onloadedmetadata = () => {
                    file.duration = tempAudio.duration;
                    const li = dom.playlistEl.querySelector(`[data-index='${playlistFiles.indexOf(file)}'] .playlist-track-duration`);
                    if (li) li.textContent = formatTime(file.duration);
                    resolve(file.duration);
                };
                tempAudio.onerror = () => resolve(0);
            });
        }

        async function calculateTotalDuration() {
            if (isSingleM4B) return;
            const durations = await Promise.all(playlistFiles.map(getFileDuration));
            totalPlaylistDuration = durations.reduce((acc, curr) => acc + curr, 0);
            updateTotalTimeInfo();
        }

        function updateTotalTimeInfo() {
            if (totalPlaylistDuration <= 0 || isNaN(audio.currentTime) || audio.playbackRate <= 0) {
                dom.totalTimeInfo.textContent = '';
                return;
            }

            // --- PART C: Total time at normal x1 speed ---
            const totalNormalTime = totalPlaylistDuration;

            // --- PART B: Total time it will take at the CURRENT speed ---
            const totalAdjustedTime = totalNormalTime / audio.playbackRate;

            // --- PART A: Remaining time to listen (with auto-speed consideration) ---
            // First, calculate how much content (at 1x speed) is left to play.
            let timeElapsedSoFar = 0;
            if (isSingleM4B) {
                timeElapsedSoFar = audio.currentTime;
            } else {
                for (let i = 0; i < currentTrackIndex; i++) {
                    if (playlistFiles[i] && typeof playlistFiles[i].duration === 'number') {
                        timeElapsedSoFar += playlistFiles[i].duration;
                    }
                }
                timeElapsedSoFar += audio.currentTime;
            }
            const remainingSecondsNormal = totalNormalTime - timeElapsedSoFar;

            let remainingTimeAdjusted;
            if (autoSpeedActive) {
                // Use the predictive function if auto-speed is on
                remainingTimeAdjusted = calculateAutoSpeedAdjustedTime(remainingSecondsNormal, audio.playbackRate);
            } else {
                // Otherwise, a simple division is enough
                remainingTimeAdjusted = remainingSecondsNormal / audio.playbackRate;
            }
            // Ensure time doesn't go below zero
            remainingTimeAdjusted = Math.max(0, remainingTimeAdjusted);
            
            // --- Format and Display A/B/C ---
            const formattedA = formatTime(remainingTimeAdjusted, true);
            const formattedB = formatTime(totalAdjustedTime, true);
            const formattedC = formatTime(totalNormalTime, true);

            dom.totalTimeInfo.innerHTML = `<strong>${formattedA}</strong> / ${formattedB} / ${formattedC}`;
        }

        /**
         * Predicts the total listening time remaining, accounting for future speed increases
         * from the auto-speed feature.
         * @param {number} remainingSeconds - The amount of audio content left at 1.0x speed.
         * @param {number} currentSpeed - The current playback rate.
         * @returns {number} The predicted total time in seconds to finish the remaining audio.
         */
        function calculateAutoSpeedAdjustedTime(remainingSeconds, currentSpeed) {
            let totalAdjustedTime = 0;
            let speed = currentSpeed;
            let secondsLeftToProcess = remainingSeconds;
            const autoSpeedIntervalSeconds = AUTO_SPEED_INTERVAL_MS / 1000;

            while (secondsLeftToProcess > 0 && speed < SPEED_MAX) {
                const contentInNextInterval = autoSpeedIntervalSeconds * speed;
                if (secondsLeftToProcess <= contentInNextInterval) {
                    totalAdjustedTime += secondsLeftToProcess / speed;
                    secondsLeftToProcess = 0;
                } else {
                    totalAdjustedTime += autoSpeedIntervalSeconds;
                    secondsLeftToProcess -= contentInNextInterval;
                    speed = parseFloat((speed + AUTO_SPEED_INCREMENT).toFixed(2));
                }
            }
            if (secondsLeftToProcess > 0) {
                 totalAdjustedTime += secondsLeftToProcess / SPEED_MAX;
            }
            return totalAdjustedTime;
        }

        function updatePlaylistUI() {
            Array.from(dom.playlistEl.children).forEach((item, index) => {
                const isActive = index === currentTrackIndex;
                item.classList.toggle('active', isActive);
                if (isActive) {
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            });
        }

        function formatTime(seconds, showHoursEvenIfZero = false) {
            if (isNaN(seconds) || seconds < 0) return "0:00";
            seconds = Math.round(seconds);
            let h = Math.floor(seconds / 3600);
            let m = Math.floor((seconds % 3600) / 60);
            let s = Math.floor(seconds % 60);

            const sFmt = s.toString().padStart(2, '0');
            const mFmt = (h > 0 || (showHoursEvenIfZero && totalPlaylistDuration >= 3600)) ? m.toString().padStart(2, '0') : m.toString();

            if (h > 0 || (showHoursEvenIfZero && totalPlaylistDuration >= 3600)) {
                return `${h}:${mFmt}:${sFmt}`;
            } else {
                return `${mFmt}:${sFmt}`;
            }
        }

        // --- HISTORY FUNCTIONS ---
        function getHistory() {
            try {
                return JSON.parse(localStorage.getItem(HISTORY_KEY)) || [];
            } catch (e) { return []; }
        }

        function saveHistory(history) {
            localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        }

        function updateAndSaveHistory(bookData) {
            if (!bookData.id) return;
            let history = getHistory();
            history = history.filter(item => item.id !== bookData.id);
            history.unshift(bookData);
            history = history.slice(0, MAX_HISTORY_ITEMS);
            saveHistory(history);
        }

        function renderHistory() {
            const history = getHistory();
            dom.historyGrid.innerHTML = '';
            if (history.length === 0) {
                dom.historySection.style.display = 'none';
                return;
            }
            dom.historySection.style.display = 'block';

            history.forEach(book => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.dataset.bookId = book.id;
                item.title = book.title;
                item.innerHTML = `
                    <div class="history-item-artwork">
                         ${book.artwork ? `<img src="${book.artwork}" alt="${book.title}">` : artworkIcon}
                    </div>
                    <div class="title">${book.title}</div>
                    <div class="history-item-remove-btn" title="Remove from Bookshelf">
                        <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </div>
                `;
                item.addEventListener('click', (e) => {
                    if (e.target.closest('.history-item-remove-btn')) return;
                    loadFromHistory(book.id);
                });

                item.querySelector('.history-item-remove-btn').addEventListener('click', () => {
                    removeBookFromHistory(book.id);
                });

                dom.historyGrid.appendChild(item);
            });
        }

        function removeBookFromHistory(bookId) {
            let history = getHistory();
            history = history.filter(item => item.id !== bookId);
            saveHistory(history);
            localStorage.removeItem(bookId);

            const itemToRemove = dom.historyGrid.querySelector(`.history-item[data-book-id="${bookId}"]`);
            if (itemToRemove) {
                itemToRemove.style.transition = 'opacity 0.3s, transform 0.3s';
                itemToRemove.style.opacity = '0';
                itemToRemove.style.transform = 'scale(0.8)';
                setTimeout(() => renderHistory(), 300);
            }
        }

        function loadFromHistory(bookId) {
            const savedState = getSavedState(bookId);
            if (!savedState) {
                showNotification("Sorry, couldn't find the save data for that book.", "error");
                removeBookFromHistory(bookId);
                return;
            }
            pendingBookIdFromHistory = bookId;
            dom.historyLoadModal.classList.add('visible');
        }

        // --- THEME FUNCTIONS ---
        function toggleTheme() {
            const isLightTheme = document.body.classList.toggle('light-theme');
            localStorage.setItem('bookava-theme', isLightTheme ? 'light' : 'dark');
            updateThemeIcon();
        }

        function updateThemeIcon() {
            const isLightTheme = document.body.classList.contains('light-theme');
            dom.themeToggleBtn.innerHTML = isLightTheme ? themeIcons.dark : themeIcons.light;
        }

        function applySavedTheme() {
            const savedTheme = localStorage.getItem('bookava-theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            }
            updateThemeIcon();
        }

        // --- KEYBOARD SHORTCUTS ---
        function handleKeyboardShortcuts(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlayPause();
                    break;
                case 'ArrowRight':
                    seekRelative(15);
                    break;
                case 'ArrowLeft':
                    seekRelative(-15);
                    break;
            }
        }


        // --- PWA ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        // --- INITIAL SETUP ---
        dom.playPauseBtn.innerHTML = playIcon;
        dom.artworkPlaceholder.innerHTML = artworkIcon;
        updateVolumeUI();
        updateSpeedUI();
        renderHistory();
        applySavedTheme();
        setupEventListeners();
    </script>
</body>

</html>
